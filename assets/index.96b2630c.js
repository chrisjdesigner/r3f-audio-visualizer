import{g as Ie,h as he,W as C,N as q,i as ze,k as V,s as x,U as A,l as Ne,m as T,D as Fe,n as Le,o as ke,p as Oe,R as ae,q as He,L as Ee,t as o,V as D,M as Ge,S as U,v as P,P as Me,w as pe,x as Ve,y as ne,E as fe,z as J,A as ee,I as We,J as Ke,K as ue,O as Ze,Q as te,X as we,Y as Re,Z as Xe,r as _,_ as de,u as qe,b as re,$ as je}from"./index.3ba03cfd.js";let Q;function Ye(){if(Q!==void 0)return Q;try{var e;let t;const i=document.createElement("canvas");return Q=!!(window.WebGL2RenderingContext&&(t=i.getContext("webgl2"))),t&&((e=t.getExtension("WEBGL_lose_context"))===null||e===void 0||e.loseContext()),Q}catch{return Q=!1}}/**
 * postprocessing v6.29.3 build Sun Jan 01 2023
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2023 Raoul van RÃ¼schen
 * @license Zlib
 */var Qe=`#include <packing>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
uniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));
#if __VERSION__ < 300
float l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#else
float l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#endif
l0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`,j="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",$e=class extends U{constructor(){super({name:"AdaptiveLuminanceMaterial",defines:{THREE_REVISION:ae.replace(/\D+/g,""),MIP_LEVEL_1X1:"0.0"},uniforms:{luminanceBuffer0:new o(null),luminanceBuffer1:new o(null),minLuminance:new o(.01),deltaTime:new o(0),tau:new o(1)},extensions:{shaderTextureLOD:!0},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:Qe,vertexShader:j}),this.toneMapped=!1}set luminanceBuffer0(e){this.uniforms.luminanceBuffer0.value=e}setLuminanceBuffer0(e){this.uniforms.luminanceBuffer0.value=e}set luminanceBuffer1(e){this.uniforms.luminanceBuffer1.value=e}setLuminanceBuffer1(e){this.uniforms.luminanceBuffer1.value=e}set mipLevel1x1(e){this.defines.MIP_LEVEL_1X1=e.toFixed(1),this.needsUpdate=!0}setMipLevel1x1(e){this.mipLevel1x1=e}set deltaTime(e){this.uniforms.deltaTime.value=e}setDeltaTime(e){this.uniforms.deltaTime.value=e}get minLuminance(){return this.uniforms.minLuminance.value}set minLuminance(e){this.uniforms.minLuminance.value=e}getMinLuminance(){return this.uniforms.minLuminance.value}setMinLuminance(e){this.uniforms.minLuminance.value=e}get adaptationRate(){return this.uniforms.tau.value}set adaptationRate(e){this.uniforms.tau.value=e}getAdaptationRate(){return this.uniforms.tau.value}setAdaptationRate(e){this.uniforms.tau.value=e}},Je=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`,ie=class extends U{constructor(e=!1,t=!1){super({name:"BokehMaterial",defines:{PASS:e?"2":"1"},uniforms:{inputBuffer:new o(null),cocBuffer:new o(null),texelSize:new o(new T),kernel64:new o(null),kernel16:new o(null),scale:new o(1)},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:Je,vertexShader:j}),this.toneMapped=!1,t&&(this.defines.FOREGROUND="1"),this.generateKernel()}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}set cocBuffer(e){this.uniforms.cocBuffer.value=e}setCoCBuffer(e){this.uniforms.cocBuffer.value=e}get scale(){return this.uniforms.scale.value}set scale(e){this.uniforms.scale.value=e}getScale(e){return this.scale}setScale(e){this.scale=e}generateKernel(){const e=2.39996323,t=new Float64Array(128),i=new Float64Array(32);let s=0,n=0;for(let r=0,a=Math.sqrt(80);r<80;++r){const l=r*e,u=Math.sqrt(r)/a,c=u*Math.cos(l),d=u*Math.sin(l);r%5===0?(i[n++]=c,i[n++]=d):(t[s++]=c,t[s++]=d)}this.uniforms.kernel64.value=t,this.uniforms.kernel16.value=i}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}};function me(e,t,i){return e*(t-i)-t}function ce(e,t,i){return Math.min(Math.max((e+t)/(t-i),0),1)}var et=`#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`,tt=class extends U{constructor(e){super({name:"CircleOfConfusionMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new o(null),focusDistance:new o(0),focusRange:new o(0),cameraNear:new o(.3),cameraFar:new o(1e3)},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:et,vertexShader:j}),this.toneMapped=!1,this.uniforms.focalLength=this.uniforms.focusRange,this.copyCameraSettings(e)}get near(){return this.uniforms.cameraNear.value}get far(){return this.uniforms.cameraFar.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=V){this.depthBuffer=e,this.depthPacking=t}get focusDistance(){return this.uniforms.focusDistance.value}set focusDistance(e){this.uniforms.focusDistance.value=e}get worldFocusDistance(){return-me(this.focusDistance,this.near,this.far)}set worldFocusDistance(e){this.focusDistance=ce(-e,this.near,this.far)}getFocusDistance(e){this.uniforms.focusDistance.value=e}setFocusDistance(e){this.uniforms.focusDistance.value=e}get focalLength(){return this.focusRange}set focalLength(e){this.focusRange=e}get focusRange(){return this.uniforms.focusRange.value}set focusRange(e){this.uniforms.focusRange.value=e}get worldFocusRange(){return-me(this.focusRange,this.near,this.far)}set worldFocusRange(e){this.focusRange=ce(-e,this.near,this.far)}getFocalLength(e){return this.focusRange}setFocalLength(e){this.focusRange=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof Me?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}},h={SKIP:9,SET:30,ADD:0,ALPHA:1,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},_e={RED:0,GREEN:1,BLUE:2,ALPHA:3},F={NONE:0,DEPTH:1,CONVOLUTION:2},f={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},W={VERY_SMALL:0,SMALL:1,MEDIUM:2,LARGE:3,VERY_LARGE:4,HUGE:5},Ce={DISCARD:0,MULTIPLY:1,MULTIPLY_RGB_SET_ALPHA:2},N={REINHARD:0,REINHARD2:1,REINHARD2_ADAPTIVE:2,OPTIMIZED_CINEON:3,ACES_FILMIC:4},se={DEFAULT:0,ESKIL:1},it=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`,st="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",nt=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],Be=class extends U{constructor(e=new ue){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new o(null),texelSize:new o(new ue),scale:new o(1),kernel:new o(0)},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:it,vertexShader:st}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernelSize=W.MEDIUM}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.inputBuffer=e}get kernelSequence(){return nt[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(e){this.uniforms.scale.value=e}getScale(){return this.uniforms.scale.value}setScale(e){this.uniforms.scale.value=e}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(e){this.uniforms.kernel.value=e}setKernel(e){this.kernel=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t,e*.5,t*.5)}setSize(e,t){const i=1/e,s=1/t;this.uniforms.texelSize.value.set(i,s,i*.5,s*.5)}},rt=`#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
#include <dithering_fragment>
}`,ye=class extends U{constructor(){super({name:"CopyMaterial",uniforms:{inputBuffer:new o(null),opacity:new o(1)},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:rt,vertexShader:j}),this.toneMapped=!1}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}getOpacity(e){return this.uniforms.opacity.value}setOpacity(e){this.uniforms.opacity.value=e}},at=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[]=float[4](abs(c-samples[0]),abs(c-samples[1]),abs(c-samples[2]),abs(c-samples[3]));float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[]=float[4](readDepth(vUv0),readDepth(vUv1),readDepth(vUv2),readDepth(vUv3));int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[]=vec3[4](texture2D(normalBuffer,vUv0).rgb,texture2D(normalBuffer,vUv1).rgb,texture2D(normalBuffer,vUv2).rgb,texture2D(normalBuffer,vUv3).rgb);
#else
vec3 n[]=vec3[4](vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));
#endif
gl_FragColor=vec4(n[index],d[index]);}`,ot="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",lt=class extends U{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new o(null),normalBuffer:new o(null),texelSize:new o(new T)},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:at,vertexShader:ot}),this.toneMapped=!1}set depthBuffer(e){this.uniforms.depthBuffer.value=e}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=V){this.depthBuffer=e,this.depthPacking=t}set normalBuffer(e){this.uniforms.normalBuffer.value=e,e!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(e){this.normalBuffer=e}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t)}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},ut=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <encodings_fragment>
}`,ct="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",ht=class extends U{constructor(){super({name:"DownsamplingMaterial",uniforms:{inputBuffer:new o(null),texelSize:new o(new T)},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:ut,vertexShader:ct}),this.toneMapped=!1}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},ft=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`,dt="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}",vt=class extends U{constructor(e,t,i,s,n=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:ae.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new o(null),depthBuffer:new o(null),resolution:new o(new T),texelSize:new o(new T),cameraNear:new o(.3),cameraFar:new o(1e3),aspect:new o(1),time:new o(0)},blending:P,depthWrite:!1,depthTest:!1,dithering:n}),this.toneMapped=!1,e&&this.setShaderParts(e),t&&this.setDefines(t),i&&this.setUniforms(i),this.copyCameraSettings(s)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(e){this.uniforms.depthBuffer.value=e}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(e){this.defines.DEPTH_PACKING=e.toFixed(0),this.needsUpdate=!0}setDepthBuffer(e,t=V){this.depthBuffer=e,this.depthPacking=t}setShaderData(e){this.setShaderParts(e.shaderParts),this.setDefines(e.defines),this.setUniforms(e.uniforms),this.setExtensions(e.extensions)}setShaderParts(e){var t,i,s,n,r;return this.fragmentShader=ft.replace(f.FRAGMENT_HEAD,(t=e.get(f.FRAGMENT_HEAD))!=null?t:"").replace(f.FRAGMENT_MAIN_UV,(i=e.get(f.FRAGMENT_MAIN_UV))!=null?i:"").replace(f.FRAGMENT_MAIN_IMAGE,(s=e.get(f.FRAGMENT_MAIN_IMAGE))!=null?s:""),this.vertexShader=dt.replace(f.VERTEX_HEAD,(n=e.get(f.VERTEX_HEAD))!=null?n:"").replace(f.VERTEX_MAIN_SUPPORT,(r=e.get(f.VERTEX_MAIN_SUPPORT))!=null?r:""),this.needsUpdate=!0,this}setDefines(e){for(const t of e.entries())this.defines[t[0]]=t[1];return this.needsUpdate=!0,this}setUniforms(e){for(const t of e.entries())this.uniforms[t[0]]=t[1];return this}setExtensions(e){this.extensions={};for(const t of e)this.extensions[t]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(e){this.encodeOutput!==e&&(e?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(e){return this.encodeOutput}setOutputEncodingEnabled(e){this.encodeOutput=e}get time(){return this.uniforms.time.value}set time(e){this.uniforms.time.value=e}setDeltaTime(e){this.uniforms.time.value+=e}adoptCameraSettings(e){this.copyCameraSettings(e)}copyCameraSettings(e){e&&(this.uniforms.cameraNear.value=e.near,this.uniforms.cameraFar.value=e.far,e instanceof Me?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(e,t){const i=this.uniforms;i.resolution.value.set(e,t),i.texelSize.value.set(1/e,1/t),i.aspect.value=e/t}static get Section(){return f}},pt=`#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`,mt=class extends U{constructor(e=!1,t=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:ae.replace(/\D+/g,"")},uniforms:{inputBuffer:new o(null),threshold:new o(0),smoothing:new o(1),range:new o(null)},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:pt,vertexShader:j}),this.toneMapped=!1,this.colorOutput=e,this.luminanceRange=t}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}get threshold(){return this.uniforms.threshold.value}set threshold(e){this.smoothing>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=e}getThreshold(){return this.threshold}setThreshold(e){this.threshold=e}get smoothing(){return this.uniforms.smoothing.value}set smoothing(e){this.threshold>0||e>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=e}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(e){this.smoothing=e}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(e){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(e){e?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(e){return this.colorOutput}setColorOutputEnabled(e){this.colorOutput=e}get useRange(){return this.luminanceRange!==null}set useRange(e){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(e){e!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=e,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(e){this.luminanceRange=e}},gt=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`,xt=class extends U{constructor(e=null){super({name:"MaskMaterial",uniforms:{maskTexture:new o(e),inputBuffer:new o(null),strength:new o(1)},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:gt,vertexShader:j}),this.toneMapped=!1,this.setColorChannel(_e.RED),this.setMaskFunction(Ce.DISCARD)}set inputBuffer(e){this.uniforms.inputBuffer.value=e}setInputBuffer(e){this.uniforms.inputBuffer.value=e}set maskTexture(e){this.uniforms.maskTexture.value=e,delete this.defines.MASK_PRECISION_HIGH,e.type!==A&&(this.defines.MASK_PRECISION_HIGH="1"),this.needsUpdate=!0}setMaskTexture(e){this.maskTexture=e}set colorChannel(e){this.defines.COLOR_CHANNEL=e.toFixed(0),this.needsUpdate=!0}setColorChannel(e){this.colorChannel=e}set maskFunction(e){this.defines.MASK_FUNCTION=e.toFixed(0),this.needsUpdate=!0}setMaskFunction(e){this.maskFunction=e}get inverted(){return this.defines.INVERTED!==void 0}set inverted(e){this.inverted&&!e?delete this.defines.INVERTED:e&&(this.defines.INVERTED="1"),this.needsUpdate=!0}isInverted(){return this.inverted}setInverted(e){this.inverted=e}get strength(){return this.uniforms.strength.value}set strength(e){this.uniforms.strength.value=e}getStrength(){return this.strength}setStrength(e){this.strength=e}},St=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`,Tt="uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}",Et=class extends Be{constructor({kernelSize:e=W.MEDIUM,offset:t=0,rotation:i=0,focusArea:s=.4,feather:n=.3}={}){super(),this.fragmentShader=St,this.vertexShader=Tt,this.kernelSize=e,this.uniforms.aspect=new o(1),this.uniforms.rotation=new o(new T),this.uniforms.maskParams=new o(new ue),this._offset=t,this._focusArea=s,this._feather=n,this.rotation=i,this.updateParams()}updateParams(){const e=this.uniforms.maskParams.value,t=Math.max(this.focusArea,0),i=Math.max(t-this.feather,0);e.set(this.offset-t,this.offset-i,this.offset+t,this.offset+i)}get rotation(){return Math.acos(this.uniforms.rotation.value.x)}set rotation(e){this.uniforms.rotation.value.set(Math.cos(e),Math.sin(e))}get offset(){return this._offset}set offset(e){this._offset=e,this.updateParams()}get focusArea(){return this._focusArea}set focusArea(e){this._focusArea=e,this.updateParams()}get feather(){return this._feather}set feather(e){this._feather=e,this.updateParams()}setSize(e,t){super.setSize(e,t),this.uniforms.aspect.value=e/t}},Mt=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <encodings_fragment>
}`,wt="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",Rt=class extends U{constructor(){super({name:"UpsamplingMaterial",uniforms:{inputBuffer:new o(null),supportBuffer:new o(null),texelSize:new o(new T),radius:new o(.85)},blending:P,depthWrite:!1,depthTest:!1,fragmentShader:Mt,vertexShader:wt}),this.toneMapped=!1}set inputBuffer(e){this.uniforms.inputBuffer.value=e}set supportBuffer(e){this.uniforms.supportBuffer.value=e}get radius(){return this.uniforms.radius.value}set radius(e){this.uniforms.radius.value=e}setSize(e,t){this.uniforms.texelSize.value.set(1/e,1/t)}},_t=new Ie,H=null;function Ct(){if(H===null){const e=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),t=new Float32Array([0,0,2,0,0,2]);H=new Ze,H.setAttribute!==void 0?(H.setAttribute("position",new te(e,3)),H.setAttribute("uv",new te(t,2))):(H.addAttribute("position",new te(e,3)),H.addAttribute("uv",new te(t,2)))}return H}var B=class{constructor(e="Pass",t=new pe,i=_t){this.name=e,this.renderer=null,this.scene=t,this.camera=i,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(e){if(this.rtt===e){const t=this.fullscreenMaterial;t!==null&&(t.needsUpdate=!0),this.rtt=!e}}set mainScene(e){}set mainCamera(e){}setRenderer(e){this.renderer=e}isEnabled(){return this.enabled}setEnabled(e){this.enabled=e}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(e){let t=this.screen;t!==null?t.material=e:(t=new Ve(Ct(),e),t.frustumCulled=!1,this.scene===null&&(this.scene=new pe),this.scene.add(t),this.screen=t)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(e){this.fullscreenMaterial=e}getDepthTexture(){return null}setDepthTexture(e,t=V){}render(e,t,i,s,n){throw new Error("Render method not implemented!")}setSize(e,t){}initialize(e,t,i){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof C||t instanceof we||t instanceof Re||t instanceof B)&&this[e].dispose()}}},be=class extends B{constructor(e,t=!0){super("CopyPass"),this.fullscreenMaterial=new ye,this.needsSwap=!1,this.renderTarget=e,e===void 0&&(this.renderTarget=new C(1,1,{minFilter:ne,magFilter:ne,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=t}get resize(){return this.autoResize}set resize(e){this.autoResize=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(e){this.autoResize=e}render(e,t,i,s,n){this.fullscreenMaterial.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){this.autoResize&&this.renderTarget.setSize(e,t)}initialize(e,t,i){i!==void 0&&(this.renderTarget.texture.type=i,i!==A?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":e.outputEncoding===x&&(this.renderTarget.texture.encoding=x))}},Bt=class extends B{constructor(e,{minLuminance:t=.01,adaptationRate:i=1}={}){super("AdaptiveLuminancePass"),this.fullscreenMaterial=new $e,this.needsSwap=!1,this.renderTargetPrevious=new C(1,1,{minFilter:q,magFilter:q,depthBuffer:!1}),this.renderTargetPrevious.texture.name="Luminance.Previous";const s=this.fullscreenMaterial;s.luminanceBuffer0=this.renderTargetPrevious.texture,s.luminanceBuffer1=e,s.minLuminance=t,s.adaptationRate=i,this.renderTargetAdapted=this.renderTargetPrevious.clone(),this.renderTargetAdapted.texture.name="Luminance.Adapted",this.copyPass=new be(this.renderTargetPrevious,!1)}get texture(){return this.renderTargetAdapted.texture}getTexture(){return this.renderTargetAdapted.texture}set mipLevel1x1(e){this.fullscreenMaterial.mipLevel1x1=e}get adaptationRate(){return this.fullscreenMaterial.adaptationRate}set adaptationRate(e){this.fullscreenMaterial.adaptationRate=e}render(e,t,i,s,n){this.fullscreenMaterial.deltaTime=s,e.setRenderTarget(this.renderToScreen?null:this.renderTargetAdapted),e.render(this.scene,this.camera),this.copyPass.render(e,this.renderTargetAdapted)}},yt=class extends B{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(e,t,i,s,n){const r=e.state.buffers.stencil;r.setLocked(!1),r.setTest(!1)}},ge=new he,De=class extends B{constructor(e=!0,t=!0,i=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=e,this.depth=t,this.stencil=i,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(e,t,i){this.color=e,this.depth=t,this.stencil=i}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(e){this.overrideClearColor=e}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(e){this.overrideClearAlpha=e}render(e,t,i,s,n){const r=this.overrideClearColor,a=this.overrideClearAlpha,l=e.getClearAlpha(),u=r!==null,c=a>=0;u?(e.getClearColor(ge),e.setClearColor(r,c?a:l)):c&&e.setClearAlpha(a),e.setRenderTarget(this.renderToScreen?null:t),e.clear(this.color,this.depth,this.stencil),u?e.setClearColor(ge,l):c&&e.setClearAlpha(l)}},G=-1,S=class extends fe{constructor(e,t=G,i=G,s=1){super(),this.resizable=e,this.baseSize=new T(1,1),this.preferredSize=new T(t,i),this.target=this.preferredSize,this.s=s,this.effectiveSize=new T,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const e=this.baseSize,t=this.preferredSize,i=this.effectiveSize,s=this.scale;t.width!==G?i.width=t.width:t.height!==G?i.width=Math.round(t.height*(e.width/Math.max(e.height,1))):i.width=Math.round(e.width*s),t.height!==G?i.height=t.height:t.width!==G?i.height=Math.round(t.width/Math.max(e.width/Math.max(e.height,1),1)):i.height=Math.round(e.height*s)}get width(){return this.effectiveSize.width}set width(e){this.preferredWidth=e}get height(){return this.effectiveSize.height}set height(e){this.preferredHeight=e}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(e){this.s!==e&&(this.s=e,this.preferredSize.setScalar(G),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(e){this.scale=e}get baseWidth(){return this.baseSize.width}set baseWidth(e){this.baseSize.width!==e&&(this.baseSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(e){this.baseWidth=e}get baseHeight(){return this.baseSize.height}set baseHeight(e){this.baseSize.height!==e&&(this.baseSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(e){this.baseHeight=e}setBaseSize(e,t){(this.baseSize.width!==e||this.baseSize.height!==t)&&(this.baseSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(e){this.preferredSize.width!==e&&(this.preferredSize.width=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(e){this.preferredWidth=e}get preferredHeight(){return this.preferredSize.height}set preferredHeight(e){this.preferredSize.height!==e&&(this.preferredSize.height=e,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(e){this.preferredHeight=e}setPreferredSize(e,t){(this.preferredSize.width!==e||this.preferredSize.height!==t)&&(this.preferredSize.set(e,t),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(e){this.s=e.scale,this.baseSize.set(e.baseWidth,e.baseHeight),this.preferredSize.set(e.preferredWidth,e.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return G}},oe=!1,xe=class{constructor(e=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(e),this.meshCount=0,this.replaceMaterial=t=>{if(t.isMesh){let i;if(t.material.flatShading)switch(t.material.side){case ee:i=this.materialsFlatShadedDoubleSide;break;case J:i=this.materialsFlatShadedBackSide;break;default:i=this.materialsFlatShaded;break}else switch(t.material.side){case ee:i=this.materialsDoubleSide;break;case J:i=this.materialsBackSide;break;default:i=this.materials;break}this.originalMaterials.set(t,t.material),t.isSkinnedMesh?t.material=i[2]:t.isInstancedMesh?t.material=i[1]:t.material=i[0],++this.meshCount}}}setMaterial(e){if(this.disposeMaterials(),this.material=e,e!==null){const t=this.materials=[e.clone(),e.clone(),e.clone()];for(const i of t)i.uniforms=Object.assign({},e.uniforms),i.side=We;t[2].skinning=!0,this.materialsBackSide=t.map(i=>{const s=i.clone();return s.uniforms=Object.assign({},e.uniforms),s.side=J,s}),this.materialsDoubleSide=t.map(i=>{const s=i.clone();return s.uniforms=Object.assign({},e.uniforms),s.side=ee,s}),this.materialsFlatShaded=t.map(i=>{const s=i.clone();return s.uniforms=Object.assign({},e.uniforms),s.flatShading=!0,s}),this.materialsFlatShadedBackSide=t.map(i=>{const s=i.clone();return s.uniforms=Object.assign({},e.uniforms),s.flatShading=!0,s.side=J,s}),this.materialsFlatShadedDoubleSide=t.map(i=>{const s=i.clone();return s.uniforms=Object.assign({},e.uniforms),s.flatShading=!0,s.side=ee,s})}}render(e,t,i){const s=e.shadowMap.enabled;if(e.shadowMap.enabled=!1,oe){const n=this.originalMaterials;this.meshCount=0,t.traverse(this.replaceMaterial),e.render(t,i);for(const r of n)r[0].material=r[1];this.meshCount!==n.size&&n.clear()}else{const n=t.overrideMaterial;t.overrideMaterial=this.material,e.render(t,i),t.overrideMaterial=n}e.shadowMap.enabled=s}disposeMaterials(){if(this.material!==null){const e=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const t of e)t.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return oe}static set workaroundEnabled(e){oe=e}},Ue=class extends B{constructor(e,t,i=null){super("RenderPass",e,t),this.needsSwap=!1,this.clearPass=new De,this.overrideMaterialManager=i===null?null:new xe(i),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get renderToScreen(){return super.renderToScreen}set renderToScreen(e){super.renderToScreen=e,this.clearPass.renderToScreen=e}get overrideMaterial(){const e=this.overrideMaterialManager;return e!==null?e.material:null}set overrideMaterial(e){const t=this.overrideMaterialManager;e!==null?t!==null?t.setMaterial(e):this.overrideMaterialManager=new xe(e):t!==null&&(t.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(e){this.overrideMaterial=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getSelection(){return this.selection}setSelection(e){this.selection=e}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(e){this.ignoreBackground=e}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(e){this.skipShadowMapUpdate=e}getClearPass(){return this.clearPass}render(e,t,i,s,n){const r=this.scene,a=this.camera,l=this.selection,u=a.layers.mask,c=r.background,d=e.shadowMap.autoUpdate,v=this.renderToScreen?null:t;l!==null&&a.layers.set(l.getLayer()),this.skipShadowMapUpdate&&(e.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(r.background=null),this.clearPass.enabled&&this.clearPass.render(e,t),e.setRenderTarget(v),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(e,r,a):e.render(r,a),a.layers.mask=u,r.background=c,e.shadowMap.autoUpdate=d}},bt=class extends B{constructor({normalBuffer:e=null,resolutionScale:t=.5,width:i=S.AUTO_SIZE,height:s=S.AUTO_SIZE,resolutionX:n=i,resolutionY:r=s}={}){super("DepthDownsamplingPass");const a=new lt;a.normalBuffer=e,this.fullscreenMaterial=a,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new C(1,1,{minFilter:q,magFilter:q,depthBuffer:!1,type:ze}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const l=this.resolution=new S(this,n,r,t);l.addEventListener("change",u=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(e,t=V){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t}render(e,t,i,s,n){e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t),this.renderTarget.setSize(i.width,i.height),this.fullscreenMaterial.setSize(e,t)}initialize(e,t,i){const s=e.getContext();if(!(s.getExtension("EXT_color_buffer_float")||s.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}};function Se(e,t,i){for(const s of t){const n="$1"+e+s.charAt(0).toUpperCase()+s.slice(1),r=new RegExp("([^\\.])(\\b"+s+"\\b)","g");for(const a of i.entries())a[1]!==null&&i.set(a[0],a[1].replace(r,n))}}function Dt(e,t,i){var s,n,r,a,l;let u=t.getFragmentShader(),c=t.getVertexShader();const d=u!==void 0&&/mainImage/.test(u),v=u!==void 0&&/mainUv/.test(u);if(i.attributes|=t.getAttributes(),u===void 0)throw new Error(`Missing fragment shader (${t.name})`);if(v&&(i.attributes&F.CONVOLUTION)!==0)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);if(!d&&!v)throw new Error(`Could not find mainImage or mainUv function (${t.name})`);{const m=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,p=i.shaderParts;let w=(s=p.get(f.FRAGMENT_HEAD))!=null?s:"",L=(n=p.get(f.FRAGMENT_MAIN_UV))!=null?n:"",I=(r=p.get(f.FRAGMENT_MAIN_IMAGE))!=null?r:"",K=(a=p.get(f.VERTEX_HEAD))!=null?a:"",R=(l=p.get(f.VERTEX_MAIN_SUPPORT))!=null?l:"";const z=new Set,M=new Set;if(v&&(L+=`	${e}MainUv(UV);
`,i.uvTransformation=!0),c!==null&&/mainSupport/.test(c)){const g=/mainSupport *\([\w\s]*?uv\s*?\)/.test(c);R+=`	${e}MainSupport(`,R+=g?`vUv);
`:`);
`;for(const E of c.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const O of E[1].split(/\s*,\s*/))i.varyings.add(O),z.add(O),M.add(O);for(const E of c.matchAll(m))M.add(E[1])}for(const g of u.matchAll(m))M.add(g[1]);for(const g of t.defines.keys())M.add(g.replace(/\([\w\s,]*\)/g,""));for(const g of t.uniforms.keys())M.add(g);M.delete("while"),M.delete("for"),M.delete("if"),t.uniforms.forEach((g,E)=>i.uniforms.set(e+E.charAt(0).toUpperCase()+E.slice(1),g)),t.defines.forEach((g,E)=>i.defines.set(e+E.charAt(0).toUpperCase()+E.slice(1),g));const k=new Map([["fragment",u],["vertex",c]]);Se(e,M,i.defines),Se(e,M,k),u=k.get("fragment"),c=k.get("vertex");const Z=t.blendMode;if(i.blendModes.set(Z.blendFunction,Z),d){t.inputColorSpace!==null&&t.inputColorSpace!==i.colorSpace&&(I+=t.inputColorSpace===x?`color0 = LinearTosRGB(color0);
	`:`color0 = sRGBToLinear(color0);
	`),t.outputColorSpace!==null?i.colorSpace=t.outputColorSpace:t.inputColorSpace!==null&&(i.colorSpace=t.inputColorSpace);const g=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;I+=`${e}MainImage(color0, UV, `,(i.attributes&F.DEPTH)!==0&&g.test(u)&&(I+="depth, ",i.readDepth=!0),I+=`color1);
	`;const E=e+"BlendOpacity";i.uniforms.set(E,Z.opacity),I+=`color0 = blend${Z.blendFunction}(color0, color1, ${E});

	`,w+=`uniform float ${E};

`}if(w+=u+`
`,c!==null&&(K+=c+`
`),p.set(f.FRAGMENT_HEAD,w),p.set(f.FRAGMENT_MAIN_UV,L),p.set(f.FRAGMENT_MAIN_IMAGE,I),p.set(f.VERTEX_HEAD,K),p.set(f.VERTEX_MAIN_SUPPORT,R),t.extensions!==null)for(const g of t.extensions)i.extensions.add(g)}}var Ut=class extends B{constructor(e,...t){super("EffectPass"),this.fullscreenMaterial=new vt(null,null,null,e),this.listener=i=>this.handleEvent(i),this.effects=[],this.setEffects(t),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(e){for(const t of this.effects)t.mainScene=e}set mainCamera(e){this.fullscreenMaterial.copyCameraSettings(e);for(const t of this.effects)t.mainCamera=e}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(e){this.fullscreenMaterial.encodeOutput=e}get dithering(){return this.fullscreenMaterial.dithering}set dithering(e){const t=this.fullscreenMaterial;t.dithering=e,t.needsUpdate=!0}setEffects(e){for(const t of this.effects)t.removeEventListener("change",this.listener);this.effects=e.sort((t,i)=>i.attributes-t.attributes);for(const t of this.effects)t.addEventListener("change",this.listener)}updateMaterial(){const e=new kt;let t=0;for(const a of this.effects)if(a.blendMode.blendFunction===h.DST)e.attributes|=a.getAttributes()&F.DEPTH;else{if((e.attributes&a.getAttributes()&F.CONVOLUTION)!==0)throw new Error(`Convolution effects cannot be merged (${a.name})`);Dt("e"+t++,a,e)}let i=e.shaderParts.get(f.FRAGMENT_HEAD),s=e.shaderParts.get(f.FRAGMENT_MAIN_IMAGE),n=e.shaderParts.get(f.FRAGMENT_MAIN_UV);const r=/\bblend\b/g;for(const a of e.blendModes.values())i+=a.getShaderCode().replace(r,`blend${a.blendFunction}`)+`
`;(e.attributes&F.DEPTH)!==0?(e.readDepth&&(s=`float depth = readDepth(UV);

	`+s),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,e.colorSpace===x&&(s+=`color0 = sRGBToLinear(color0);
	`),e.uvTransformation?(n=`vec2 transformedUv = vUv;
`+n,e.defines.set("UV","transformedUv")):e.defines.set("UV","vUv"),e.shaderParts.set(f.FRAGMENT_HEAD,i),e.shaderParts.set(f.FRAGMENT_MAIN_IMAGE,s),e.shaderParts.set(f.FRAGMENT_MAIN_UV,n),e.shaderParts.forEach((a,l,u)=>u.set(l,a==null?void 0:a.trim().replace(/^#/,`
#`))),this.skipRendering=t===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(e)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(e,t=V){this.fullscreenMaterial.depthBuffer=e,this.fullscreenMaterial.depthPacking=t;for(const i of this.effects)i.setDepthTexture(e,t)}render(e,t,i,s,n){for(const r of this.effects)r.update(e,t,s);if(!this.skipRendering||this.renderToScreen){const r=this.fullscreenMaterial;r.inputBuffer=t.texture,r.time+=s*this.timeScale,e.setRenderTarget(this.renderToScreen?null:i),e.render(this.scene,this.camera)}}setSize(e,t){this.fullscreenMaterial.setSize(e,t);for(const i of this.effects)i.setSize(e,t)}initialize(e,t,i){this.renderer=e;for(const s of this.effects)s.initialize(e,t,i);this.updateMaterial(),i!==void 0&&i!==A&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const e of this.effects)e.removeEventListener("change",this.listener),e.dispose()}handleEvent(e){switch(e.type){case"change":this.recompile();break}}},ve=class extends B{constructor({kernelSize:e=W.MEDIUM,resolutionScale:t=.5,width:i=S.AUTO_SIZE,height:s=S.AUTO_SIZE,resolutionX:n=i,resolutionY:r=s}={}){super("KawaseBlurPass"),this.renderTargetA=new C(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const a=this.resolution=new S(this,n,r,t);a.addEventListener("change",l=>this.setSize(a.baseWidth,a.baseHeight)),this._blurMaterial=new Be,this._blurMaterial.kernelSize=e,this.copyMaterial=new ye}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(e){this._blurMaterial=e}get dithering(){return this.copyMaterial.dithering}set dithering(e){this.copyMaterial.dithering=e}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(e){this.blurMaterial.kernelSize=e}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get scale(){return this.blurMaterial.scale}set scale(e){this.blurMaterial.scale=e}getScale(){return this.blurMaterial.scale}setScale(e){this.blurMaterial.scale=e}getKernelSize(){return this.kernelSize}setKernelSize(e){this.kernelSize=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,i,s,n){const r=this.scene,a=this.camera,l=this.renderTargetA,u=this.renderTargetB,c=this.blurMaterial,d=c.kernelSequence;let v=t;this.fullscreenMaterial=c;for(let m=0,p=d.length;m<p;++m){const w=(m&1)===0?l:u;c.kernel=d[m],c.inputBuffer=v.texture,e.setRenderTarget(w),e.render(r,a),v=w}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=v.texture,e.setRenderTarget(this.renderToScreen?null:i),e.render(r,a)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t);const s=i.width,n=i.height;this.renderTargetA.setSize(s,n),this.renderTargetB.setSize(s,n),this.blurMaterial.setSize(e,t)}initialize(e,t,i){i!==void 0&&(this.renderTargetA.texture.type=i,this.renderTargetB.texture.type=i,i!==A?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):e.outputEncoding===x&&(this.renderTargetA.texture.encoding=x,this.renderTargetB.texture.encoding=x))}static get AUTO_SIZE(){return S.AUTO_SIZE}},Pe=class extends B{constructor({renderTarget:e,luminanceRange:t,colorOutput:i,resolutionScale:s=1,width:n=S.AUTO_SIZE,height:r=S.AUTO_SIZE,resolutionX:a=n,resolutionY:l=r}={}){super("LuminancePass"),this.fullscreenMaterial=new mt(i,t),this.needsSwap=!1,this.renderTarget=e,this.renderTarget===void 0&&(this.renderTarget=new C(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const u=this.resolution=new S(this,a,l,s);u.addEventListener("change",c=>this.setSize(u.baseWidth,u.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(e,t,i,s,n){const r=this.fullscreenMaterial;r.inputBuffer=t.texture,e.setRenderTarget(this.renderToScreen?null:this.renderTarget),e.render(this.scene,this.camera)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t),this.renderTarget.setSize(i.width,i.height)}initialize(e,t,i){i!==void 0&&i!==A&&(this.renderTarget.texture.type=i,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},Pt=class extends B{constructor(e,t){super("MaskPass",e,t),this.needsSwap=!1,this.clearPass=new De(!1,!1,!0),this.inverse=!1}set mainScene(e){this.scene=e}set mainCamera(e){this.camera=e}get inverted(){return this.inverse}set inverted(e){this.inverse=e}get clear(){return this.clearPass.enabled}set clear(e){this.clearPass.enabled=e}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(e){this.inverted=e}render(e,t,i,s,n){const r=e.getContext(),a=e.state.buffers,l=this.scene,u=this.camera,c=this.clearPass,d=this.inverted?0:1,v=1-d;a.color.setMask(!1),a.depth.setMask(!1),a.color.setLocked(!0),a.depth.setLocked(!0),a.stencil.setTest(!0),a.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),a.stencil.setFunc(r.ALWAYS,d,4294967295),a.stencil.setClear(v),a.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?c.render(e,null):(c.render(e,t),c.render(e,i))),this.renderToScreen?(e.setRenderTarget(null),e.render(l,u)):(e.setRenderTarget(t),e.render(l,u),e.setRenderTarget(i),e.render(l,u)),a.color.setLocked(!1),a.depth.setLocked(!1),a.stencil.setLocked(!1),a.stencil.setFunc(r.EQUAL,1,4294967295),a.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),a.stencil.setLocked(!0)}},At=class extends B{constructor(){super("MipmapBlurPass"),this.needsSwap=!1,this.renderTarget=new C(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Upsampling.Mipmap0",this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],this.downsamplingMaterial=new ht,this.upsamplingMaterial=new Rt,this.resolution=new T}get texture(){return this.renderTarget.texture}get levels(){return this.downsamplingMipmaps.length}set levels(e){if(this.levels!==e){const t=this.renderTarget;this.dispose(),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[];for(let i=0;i<e;++i){const s=t.clone();s.texture.name="Downsampling.Mipmap"+i,this.downsamplingMipmaps.push(s)}this.upsamplingMipmaps.push(t);for(let i=1,s=e-1;i<s;++i){const n=t.clone();n.texture.name="Upsampling.Mipmap"+i,this.upsamplingMipmaps.push(n)}this.setSize(this.resolution.x,this.resolution.y)}}get radius(){return this.upsamplingMaterial.radius}set radius(e){this.upsamplingMaterial.radius=e}render(e,t,i,s,n){const{scene:r,camera:a}=this,{downsamplingMaterial:l,upsamplingMaterial:u}=this,{downsamplingMipmaps:c,upsamplingMipmaps:d}=this;let v=t;this.fullscreenMaterial=l;for(let m=0,p=c.length;m<p;++m){const w=c[m];l.setSize(v.width,v.height),l.inputBuffer=v.texture,e.setRenderTarget(w),e.render(r,a),v=w}this.fullscreenMaterial=u;for(let m=d.length-1;m>=0;--m){const p=d[m];u.setSize(v.width,v.height),u.inputBuffer=v.texture,u.supportBuffer=c[m].texture,e.setRenderTarget(p),e.render(r,a),v=p}}setSize(e,t){const i=this.resolution;i.set(e,t);let s=i.width,n=i.height;for(let r=0,a=this.downsamplingMipmaps.length;r<a;++r)s=Math.round(s*.5),n=Math.round(n*.5),this.downsamplingMipmaps[r].setSize(s,n),r<this.upsamplingMipmaps.length&&this.upsamplingMipmaps[r].setSize(s,n)}initialize(e,t,i){if(i!==void 0){const s=this.downsamplingMipmaps.concat(this.upsamplingMipmaps);for(const n of s)n.texture.type=i;if(i!==A)this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1";else if(e.outputEncoding===x)for(const n of s)n.texture.encoding=x}}dispose(){super.dispose();for(const e of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))e.dispose()}},It=class extends B{constructor(e,t,{renderTarget:i,resolutionScale:s=1,width:n=S.AUTO_SIZE,height:r=S.AUTO_SIZE,resolutionX:a=n,resolutionY:l=r}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new Ue(e,t,new Ne);const u=this.renderPass;u.ignoreBackground=!0,u.skipShadowMapUpdate=!0;const c=u.getClearPass();c.overrideClearColor=new he(7829503),c.overrideClearAlpha=1,this.renderTarget=i,this.renderTarget===void 0&&(this.renderTarget=new C(1,1,{minFilter:q,magFilter:q}),this.renderTarget.texture.name="NormalPass.Target");const d=this.resolution=new S(this,a,l,s);d.addEventListener("change",v=>this.setSize(d.baseWidth,d.baseHeight))}set mainScene(e){this.renderPass.mainScene=e}set mainCamera(e){this.renderPass.mainCamera=e}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}render(e,t,i,s,n){const r=this.renderToScreen?null:this.renderTarget;this.renderPass.render(e,r,r)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t),this.renderTarget.setSize(i.width,i.height)}},X=class extends B{constructor(e,t="inputBuffer"){super("ShaderPass"),this.fullscreenMaterial=e,this.input=t}setInput(e){this.input=e}render(e,t,i,s,n){const r=this.fullscreenMaterial.uniforms;t!==null&&r!==void 0&&r[this.input]!==void 0&&(r[this.input].value=t.texture),e.setRenderTarget(this.renderToScreen?null:i),e.render(this.scene,this.camera)}initialize(e,t,i){i!==void 0&&i!==A&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},zt=class extends ve{constructor({offset:e=0,rotation:t=0,focusArea:i=.4,feather:s=.3,kernelSize:n=W.MEDIUM,resolutionScale:r=.5,resolutionX:a=S.AUTO_SIZE,resolutionY:l=S.AUTO_SIZE}={}){super({kernelSize:n,resolutionScale:r,resolutionX:a,resolutionY:l}),this.blurMaterial=new Et({kernelSize:n,offset:e,rotation:t,focusArea:i,feather:s})}},le=1/1e3,Nt=1e3,Ft=class{constructor(){this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(e){typeof document<"u"&&document.hidden!==void 0&&(e?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=e)}get delta(){return this._delta*le}get fixedDelta(){return this._fixedDelta*le}set fixedDelta(e){this._fixedDelta=e*Nt}get elapsed(){return this._elapsed*le}update(e){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=e!==void 0?e:performance.now(),this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()}handleEvent(e){document.hidden||(this.currentTime=performance.now())}dispose(){this.autoReset=!1}},Lt=class{constructor(e=null,{depthBuffer:t=!0,stencilBuffer:i=!1,multisampling:s=0,frameBufferType:n}={}){this.renderer=null,this.inputBuffer=this.createBuffer(t,i,n,s),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new be,this.depthTexture=null,this.passes=[],this.timer=new Ft,this.autoRenderToScreen=!0,this.setRenderer(e)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(e){const t=this.inputBuffer,i=this.multisampling;i>0&&e>0?(this.inputBuffer.samples=e,this.outputBuffer.samples=e,this.inputBuffer.dispose(),this.outputBuffer.dispose()):i!==e&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(t.depthBuffer,t.stencilBuffer,t.texture.type,e),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(e){if(this.renderer=e,e!==null){const t=e.getSize(new T),i=e.getContext().getContextAttributes().alpha,s=this.inputBuffer.texture.type;s===A&&e.outputEncoding===x&&(this.inputBuffer.texture.encoding=x,this.outputBuffer.texture.encoding=x,this.inputBuffer.dispose(),this.outputBuffer.dispose()),e.autoClear=!1,this.setSize(t.width,t.height);for(const n of this.passes)n.initialize(e,i,s)}}replaceRenderer(e,t=!0){const i=this.renderer,s=i.domElement.parentNode;return this.setRenderer(e),t&&s!==null&&(s.removeChild(i.domElement),s.appendChild(e.domElement)),i}createDepthTexture(){const e=this.depthTexture=new Fe;return this.inputBuffer.depthTexture=e,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(e.format=Le,e.type=ke):e.type=Oe,e}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const e of this.passes)e.setDepthTexture(null)}}createBuffer(e,t,i,s){const n=this.renderer,r=n===null?new T:n.getDrawingBufferSize(new T),a={minFilter:ne,magFilter:ne,stencilBuffer:t,depthBuffer:e,type:i};let l;return s>0?(l=Number(ae.replace(/\D+/g,""))<138?new He(r.width,r.height,a):new C(r.width,r.height,a),l.ignoreDepthForMultisampleCopy=!1,l.samples=s):l=new C(r.width,r.height,a),i===A&&n!==null&&n.outputEncoding===x&&(l.texture.encoding=x),l.texture.name="EffectComposer.Buffer",l.texture.generateMipmaps=!1,l}setMainScene(e){for(const t of this.passes)t.mainScene=e}setMainCamera(e){for(const t of this.passes)t.mainCamera=e}addPass(e,t){const i=this.passes,s=this.renderer,n=s.getDrawingBufferSize(new T),r=s.getContext().getContextAttributes().alpha,a=this.inputBuffer.texture.type;if(e.setRenderer(s),e.setSize(n.width,n.height),e.initialize(s,r,a),this.autoRenderToScreen&&(i.length>0&&(i[i.length-1].renderToScreen=!1),e.renderToScreen&&(this.autoRenderToScreen=!1)),t!==void 0?i.splice(t,0,e):i.push(e),this.autoRenderToScreen&&(i[i.length-1].renderToScreen=!0),e.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const l=this.createDepthTexture();for(e of i)e.setDepthTexture(l)}else e.setDepthTexture(this.depthTexture)}removePass(e){const t=this.passes,i=t.indexOf(e);if(i!==-1&&t.splice(i,1).length>0){if(this.depthTexture!==null){const r=(l,u)=>l||u.needsDepthTexture;t.reduce(r,!1)||(e.getDepthTexture()===this.depthTexture&&e.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&i===t.length&&(e.renderToScreen=!1,t.length>0&&(t[t.length-1].renderToScreen=!0))}}removeAllPasses(){const e=this.passes;this.deleteDepthTexture(),e.length>0&&(this.autoRenderToScreen&&(e[e.length-1].renderToScreen=!1),this.passes=[])}render(e){const t=this.renderer,i=this.copyPass;let s=this.inputBuffer,n=this.outputBuffer,r=!1,a,l,u;e===void 0&&(this.timer.update(),e=this.timer.delta);for(const c of this.passes)c.enabled&&(c.render(t,s,n,e,r),c.needsSwap&&(r&&(i.renderToScreen=c.renderToScreen,a=t.getContext(),l=t.state.buffers.stencil,l.setFunc(a.NOTEQUAL,1,4294967295),i.render(t,s,n,e,r),l.setFunc(a.EQUAL,1,4294967295)),u=s,s=n,n=u),c instanceof Pt?r=!0:c instanceof yt&&(r=!1))}setSize(e,t,i){const s=this.renderer,n=s.getSize(new T);(e===void 0||t===void 0)&&(e=n.width,t=n.height),(n.width!==e||n.height!==t)&&s.setSize(e,t,i);const r=s.getDrawingBufferSize(new T);this.inputBuffer.setSize(r.width,r.height),this.outputBuffer.setSize(r.width,r.height);for(const a of this.passes)a.setSize(r.width,r.height)}reset(){const e=this.timer.autoReset;this.dispose(),this.autoRenderToScreen=!0,this.timer.autoReset=e}dispose(){for(const e of this.passes)e.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose()}},kt=class{constructor(){this.shaderParts=new Map([[f.FRAGMENT_HEAD,null],[f.FRAGMENT_MAIN_UV,null],[f.FRAGMENT_MAIN_IMAGE,null],[f.VERTEX_HEAD,null],[f.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=F.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=Ee}},Ot="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",Ht="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",Gt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",Vt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",Wt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",Kt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",Zt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",Xt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",qt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",jt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",Yt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",Qt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",$t="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",Jt="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",ei="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",ti="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",ii="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",si="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",ni="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",ri="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",ai="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",oi="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",li="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",ui="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",ci="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",hi="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",fi="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",di="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",vi="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",pi="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",mi="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",gi="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",xi=new Map([[h.ADD,Ot],[h.ALPHA,Ht],[h.AVERAGE,Gt],[h.COLOR,Vt],[h.COLOR_BURN,Wt],[h.COLOR_DODGE,Kt],[h.DARKEN,Zt],[h.DIFFERENCE,Xt],[h.DIVIDE,qt],[h.DST,null],[h.EXCLUSION,jt],[h.HARD_LIGHT,Yt],[h.HARD_MIX,Qt],[h.HUE,$t],[h.INVERT,Jt],[h.INVERT_RGB,ei],[h.LIGHTEN,ti],[h.LINEAR_BURN,ii],[h.LINEAR_DODGE,si],[h.LINEAR_LIGHT,ni],[h.LUMINOSITY,ri],[h.MULTIPLY,ai],[h.NEGATION,oi],[h.NORMAL,li],[h.OVERLAY,ui],[h.PIN_LIGHT,ci],[h.REFLECT,hi],[h.SATURATION,fi],[h.SCREEN,di],[h.SOFT_LIGHT,vi],[h.SRC,pi],[h.SUBTRACT,mi],[h.VIVID_LIGHT,gi]]),Si=class extends fe{constructor(e,t=1){super(),this._blendFunction=e,this.opacity=new o(t)}getOpacity(){return this.opacity.value}setOpacity(e){this.opacity.value=e}get blendFunction(){return this._blendFunction}set blendFunction(e){this._blendFunction=e,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(e){this.blendFunction=e}getShaderCode(){return xi.get(this.blendFunction)}},y=class extends fe{constructor(e,t,{attributes:i=F.NONE,blendFunction:s=h.NORMAL,defines:n=new Map,uniforms:r=new Map,extensions:a=null,vertexShader:l=null}={}){super(),this.name=e,this.renderer=null,this.attributes=i,this.fragmentShader=t,this.vertexShader=l,this.defines=n,this.uniforms=r,this.extensions=a,this.blendMode=new Si(s),this.blendMode.addEventListener("change",u=>this.setChanged()),this._inputColorSpace=Ee,this._outputColorSpace=null}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(e){this._inputColorSpace=e,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e,this.setChanged()}set mainScene(e){}set mainCamera(e){}getName(){return this.name}setRenderer(e){this.renderer=e}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(e){this.attributes=e,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(e){this.fragmentShader=e,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(e){this.vertexShader=e,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(e,t=V){}update(e,t,i){}setSize(e,t){}initialize(e,t,i){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof C||t instanceof we||t instanceof Re||t instanceof B)&&this[e].dispose()}}},Ti=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}`,Ei=class extends y{constructor({blendFunction:e=h.SCREEN,luminanceThreshold:t=.9,luminanceSmoothing:i=.025,mipmapBlur:s=!1,intensity:n=1,radius:r=.85,levels:a=8,kernelSize:l=W.LARGE,resolutionScale:u=.5,width:c=S.AUTO_SIZE,height:d=S.AUTO_SIZE,resolutionX:v=c,resolutionY:m=d}={}){super("BloomEffect",Ti,{blendFunction:e,uniforms:new Map([["map",new o(null)],["intensity",new o(n)]])}),this.renderTarget=new C(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Bloom.Target",this.blurPass=new ve({kernelSize:l}),this.luminancePass=new Pe({colorOutput:!0}),this.luminanceMaterial.threshold=t,this.luminanceMaterial.smoothing=i,this.mipmapBlurPass=new At,this.mipmapBlurPass.enabled=s,this.mipmapBlurPass.radius=r,this.mipmapBlurPass.levels=a,this.uniforms.get("map").value=s?this.mipmapBlurPass.texture:this.renderTarget.texture;const p=this.resolution=new S(this,v,m,u);p.addEventListener("change",w=>this.setSize(p.baseWidth,p.baseHeight))}get texture(){return this.mipmapBlurPass.enabled?this.mipmapBlurPass.texture:this.renderTarget.texture}getTexture(){return this.texture}getResolution(){return this.resolution}getBlurPass(){return this.blurPass}getLuminancePass(){return this.luminancePass}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}getLuminanceMaterial(){return this.luminancePass.fullscreenMaterial}get width(){return this.resolution.width}set width(e){this.resolution.preferredWidth=e}get height(){return this.resolution.height}set height(e){this.resolution.preferredHeight=e}get dithering(){return this.blurPass.dithering}set dithering(e){this.blurPass.dithering=e}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(e){this.blurPass.kernelSize=e}get distinction(){return console.warn(this.name,"distinction was removed"),1}set distinction(e){console.warn(this.name,"distinction was removed")}get intensity(){return this.uniforms.get("intensity").value}set intensity(e){this.uniforms.get("intensity").value=e}getIntensity(){return this.intensity}setIntensity(e){this.intensity=e}getResolutionScale(){return this.resolution.scale}setResolutionScale(e){this.resolution.scale=e}update(e,t,i){const s=this.renderTarget,n=this.luminancePass;n.enabled?(n.render(e,t),this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(e,n.renderTarget):this.blurPass.render(e,n.renderTarget,s)):this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(e,t):this.blurPass.render(e,t,s)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t),this.renderTarget.setSize(i.width,i.height),this.blurPass.resolution.copy(i),this.luminancePass.setSize(e,t),this.mipmapBlurPass.setSize(e,t)}initialize(e,t,i){this.blurPass.initialize(e,t,i),this.luminancePass.initialize(e,t,i),this.mipmapBlurPass.initialize(e,t,i),i!==void 0&&(this.renderTarget.texture.type=i,e.outputEncoding===x&&(this.renderTarget.texture.encoding=x))}},Mi="uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}",wi=class extends y{constructor({blendFunction:e=h.SRC,brightness:t=0,contrast:i=0}={}){super("BrightnessContrastEffect",Mi,{blendFunction:e,uniforms:new Map([["brightness",new o(t)],["contrast",new o(i)]])}),this.inputColorSpace=x}get brightness(){return this.uniforms.get("brightness").value}set brightness(e){this.uniforms.get("brightness").value=e}getBrightness(e){return this.brightness}setBrightness(e){this.brightness=e}get contrast(){return this.uniforms.get("contrast").value}set contrast(e){this.uniforms.get("contrast").value=e}getContrast(e){return this.contrast}setContrast(e){this.contrast=e}},Ri="uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}",_i=class extends y{constructor({blendFunction:e,bits:t=16}={}){super("ColorDepthEffect",Ri,{blendFunction:e,uniforms:new Map([["factor",new o(1)]])}),this.bits=0,this.bitDepth=t}get bitDepth(){return this.bits}set bitDepth(e){this.bits=e,this.uniforms.get("factor").value=Math.pow(2,e/3)}getBitDepth(){return this.bitDepth}setBitDepth(e){this.bitDepth=e}},Ci=`void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){
#ifdef INVERTED
vec3 color=vec3(1.0-depth);
#else
vec3 color=vec3(depth);
#endif
outputColor=vec4(color,inputColor.a);}`,Bi=class extends y{constructor({blendFunction:e=h.SRC,inverted:t=!1}={}){super("DepthEffect",Ci,{blendFunction:e,attributes:F.DEPTH}),this.inverted=t}get inverted(){return this.defines.has("INVERTED")}set inverted(e){this.inverted!==e&&(e?this.defines.set("INVERTED","1"):this.defines.delete("INVERTED"),this.setChanged())}isInverted(){return this.inverted}setInverted(e){this.inverted=e}},yi=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float cocNear=texture2D(nearCoCBuffer,uv).r;cocNear=min(cocNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,cocNear);outputColor=result;}`,bi=class extends y{constructor(e,{blendFunction:t,worldFocusDistance:i,worldFocusRange:s,focusDistance:n=0,focalLength:r=.1,focusRange:a=r,bokehScale:l=1,resolutionScale:u=1,width:c=S.AUTO_SIZE,height:d=S.AUTO_SIZE,resolutionX:v=c,resolutionY:m=d}={}){super("DepthOfFieldEffect",yi,{blendFunction:t,attributes:F.DEPTH,uniforms:new Map([["nearColorBuffer",new o(null)],["farColorBuffer",new o(null)],["nearCoCBuffer",new o(null)],["scale",new o(1)]])}),this.camera=e,this.renderTarget=new C(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="DoF.Intermediate",this.renderTargetMasked=this.renderTarget.clone(),this.renderTargetMasked.texture.name="DoF.Masked.Far",this.renderTargetNear=this.renderTarget.clone(),this.renderTargetNear.texture.name="DoF.Bokeh.Near",this.uniforms.get("nearColorBuffer").value=this.renderTargetNear.texture,this.renderTargetFar=this.renderTarget.clone(),this.renderTargetFar.texture.name="DoF.Bokeh.Far",this.uniforms.get("farColorBuffer").value=this.renderTargetFar.texture,this.renderTargetCoC=this.renderTarget.clone(),this.renderTargetCoC.texture.name="DoF.CoC",this.renderTargetCoCBlurred=this.renderTargetCoC.clone(),this.renderTargetCoCBlurred.texture.name="DoF.CoC.Blurred",this.uniforms.get("nearCoCBuffer").value=this.renderTargetCoCBlurred.texture,this.cocPass=new X(new tt(e));const p=this.cocMaterial;p.focusDistance=n,p.focusRange=a,i!==void 0&&(p.worldFocusDistance=i),s!==void 0&&(p.worldFocusRange=s),this.blurPass=new ve({resolutionScale:u,resolutionX:v,resolutionY:m,kernelSize:W.MEDIUM}),this.maskPass=new X(new xt(this.renderTargetCoC.texture));const w=this.maskPass.fullscreenMaterial;w.maskFunction=Ce.MULTIPLY,w.colorChannel=_e.GREEN,this.bokehNearBasePass=new X(new ie(!1,!0)),this.bokehNearBasePass.fullscreenMaterial.cocBuffer=this.renderTargetCoCBlurred.texture,this.bokehNearFillPass=new X(new ie(!0,!0)),this.bokehNearFillPass.fullscreenMaterial.cocBuffer=this.renderTargetCoCBlurred.texture,this.bokehFarBasePass=new X(new ie(!1,!1)),this.bokehFarBasePass.fullscreenMaterial.cocBuffer=this.renderTargetCoC.texture,this.bokehFarFillPass=new X(new ie(!0,!1)),this.bokehFarFillPass.fullscreenMaterial.cocBuffer=this.renderTargetCoC.texture,this.target=null;const L=this.resolution=new S(this,v,m,u);L.addEventListener("change",I=>this.setSize(L.baseWidth,L.baseHeight)),this.bokehScale=l}set mainCamera(e){this.camera=e,this.cocMaterial.copyCameraSettings(e)}get cocTexture(){return this.renderTargetCoC.texture}get cocMaterial(){return this.cocPass.fullscreenMaterial}get circleOfConfusionMaterial(){return this.cocMaterial}getCircleOfConfusionMaterial(){return this.circleOfConfusionMaterial}getBlurPass(){return this.blurPass}getResolution(){return this.resolution}get bokehScale(){return this.uniforms.get("scale").value}set bokehScale(e){this.bokehNearBasePass.fullscreenMaterial.scale=e,this.bokehNearFillPass.fullscreenMaterial.scale=e,this.bokehFarBasePass.fullscreenMaterial.scale=e,this.bokehFarFillPass.fullscreenMaterial.scale=e,this.maskPass.fullscreenMaterial.strength=e,this.uniforms.get("scale").value=e}getBokehScale(){return this.bokehScale}setBokehScale(e){this.bokehScale=e}getTarget(){return this.target}setTarget(e){this.target=e}calculateFocusDistance(e){const t=this.camera,i=t.position.distanceTo(e);return ce(-i,t.near,t.far)}setDepthTexture(e,t=V){this.circleOfConfusionMaterial.depthBuffer=e,this.circleOfConfusionMaterial.depthPacking=t}update(e,t,i){const s=this.renderTarget,n=this.renderTargetCoC,r=this.renderTargetCoCBlurred,a=this.renderTargetMasked;if(this.target!==null){const l=this.calculateFocusDistance(this.target);this.cocMaterial.focusDistance=l}this.cocPass.render(e,null,n),this.blurPass.render(e,n,r),this.maskPass.render(e,t,a),this.bokehFarBasePass.render(e,a,s),this.bokehFarFillPass.render(e,s,this.renderTargetFar),this.bokehNearBasePass.render(e,t,s),this.bokehNearFillPass.render(e,s,this.renderTargetNear)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t);const s=i.width,n=i.height;this.cocPass.setSize(e,t),this.blurPass.setSize(e,t),this.maskPass.setSize(e,t),this.renderTargetCoC.setSize(e,t),this.renderTargetMasked.setSize(e,t),this.renderTarget.setSize(s,n),this.renderTargetNear.setSize(s,n),this.renderTargetFar.setSize(s,n),this.renderTargetCoCBlurred.setSize(s,n),this.bokehNearBasePass.fullscreenMaterial.setSize(e,t),this.bokehNearFillPass.fullscreenMaterial.setSize(e,t),this.bokehFarBasePass.fullscreenMaterial.setSize(e,t),this.bokehFarFillPass.fullscreenMaterial.setSize(e,t)}initialize(e,t,i){this.cocPass.initialize(e,t,i),this.maskPass.initialize(e,t,i),this.bokehNearBasePass.initialize(e,t,i),this.bokehNearFillPass.initialize(e,t,i),this.bokehFarBasePass.initialize(e,t,i),this.bokehFarFillPass.initialize(e,t,i),this.blurPass.initialize(e,t,A),i!==void 0&&(this.renderTarget.texture.type=i,this.renderTargetNear.texture.type=i,this.renderTargetFar.texture.type=i,this.renderTargetMasked.texture.type=i,e.outputEncoding===x&&(this.renderTarget.texture.encoding=x,this.renderTargetNear.texture.encoding=x,this.renderTargetFar.texture.encoding=x,this.renderTargetMasked.texture.encoding=x))}},Di="uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}",Ui=class extends y{constructor({blendFunction:e,angle:t=Math.PI*.5,scale:i=1}={}){super("DotScreenEffect",Di,{blendFunction:e,uniforms:new Map([["angle",new o(new T)],["scale",new o(i)]])}),this.angle=t}get angle(){return Math.acos(this.uniforms.get("angle").value.y)}set angle(e){this.uniforms.get("angle").value.set(Math.sin(e),Math.cos(e))}getAngle(){return this.angle}setAngle(e){this.angle=e}get scale(){return this.uniforms.get("scale").value}set scale(e){this.uniforms.get("scale").value=e}};new D;new Ge;var Pi="uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",Ai=class extends y{constructor({blendFunction:e=h.SRC,hue:t=0,saturation:i=0}={}){super("HueSaturationEffect",Pi,{blendFunction:e,uniforms:new Map([["hue",new o(new D)],["saturation",new o(i)]])}),this.hue=t}get saturation(){return this.uniforms.get("saturation").value}set saturation(e){this.uniforms.get("saturation").value=e}getSaturation(){return this.saturation}setSaturation(e){this.saturation=e}get hue(){const e=this.uniforms.get("hue").value;return Math.acos((e.x*3-1)/2)}set hue(e){const t=Math.sin(e),i=Math.cos(e);this.uniforms.get("hue").value.set((2*i+1)/3,(-Math.sqrt(3)*t-i+1)/3,(Math.sqrt(3)*t-i+1)/3)}getHue(){return this.hue}setHue(e){this.hue=e}};new he;var Ii=`void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`,zi=class extends y{constructor({blendFunction:e=h.SCREEN,premultiply:t=!1}={}){super("NoiseEffect",Ii,{blendFunction:e}),this.premultiply=t}get premultiply(){return this.defines.has("PREMULTIPLY")}set premultiply(e){this.premultiply!==e&&(e?this.defines.set("PREMULTIPLY","1"):this.defines.delete("PREMULTIPLY"),this.setChanged())}isPremultiplied(){return this.premultiply}setPremultiplied(e){this.premultiply=e}},Ni=`uniform float count;
#ifdef SCROLL
uniform float scrollSpeed;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;
#ifdef SCROLL
y+=time*scrollSpeed;
#endif
vec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}`,Fi=class extends y{constructor({blendFunction:e=h.OVERLAY,density:t=1.25,scrollSpeed:i=0}={}){super("ScanlineEffect",Ni,{blendFunction:e,uniforms:new Map([["count",new o(0)],["scrollSpeed",new o(0)]])}),this.resolution=new T,this.d=t,this.scrollSpeed=i}get density(){return this.d}set density(e){this.d=e,this.setSize(this.resolution.width,this.resolution.height)}getDensity(){return this.density}setDensity(e){this.density=e}get scrollSpeed(){return this.uniforms.get("scrollSpeed").value}set scrollSpeed(e){this.uniforms.get("scrollSpeed").value=e,e===0?this.defines.delete("SCROLL")&&this.setChanged():this.defines.has("SCROLL")||(this.defines.set("SCROLL","1"),this.setChanged())}setSize(e,t){this.resolution.set(e,t),this.uniforms.get("count").value=Math.round(t*this.density)}},Li="uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}",ki="uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}",Oi=Math.PI*.5,$=new D,Te=new D,Hi=class extends y{constructor(e,t=new D,{speed:i=2,maxRadius:s=1,waveSize:n=.2,amplitude:r=.05}={}){super("ShockWaveEffect",Li,{vertexShader:ki,uniforms:new Map([["active",new o(!1)],["center",new o(new T(.5,.5))],["cameraDistance",new o(1)],["size",new o(1)],["radius",new o(-n)],["maxRadius",new o(s)],["waveSize",new o(n)],["amplitude",new o(r)]])}),this.position=t,this.speed=i,this.camera=e,this.screenPosition=this.uniforms.get("center").value,this.time=0,this.active=!1}set mainCamera(e){this.camera=e}get amplitude(){return this.uniforms.get("amplitude").value}set amplitude(e){this.uniforms.get("amplitude").value=e}get waveSize(){return this.uniforms.get("waveSize").value}set waveSize(e){this.uniforms.get("waveSize").value=e}get maxRadius(){return this.uniforms.get("maxRadius").value}set maxRadius(e){this.uniforms.get("maxRadius").value=e}get epicenter(){return this.position}set epicenter(e){this.position=e}getPosition(){return this.position}setPosition(e){this.position=e}getSpeed(){return this.speed}setSpeed(e){this.speed=e}explode(){this.time=0,this.active=!0,this.uniforms.get("active").value=!0}update(e,t,i){const s=this.position,n=this.camera,r=this.uniforms,a=r.get("active");if(this.active){const l=r.get("waveSize").value;n.getWorldDirection($),Te.copy(n.position).sub(s),a.value=$.angleTo(Te)>Oi,a.value&&(r.get("cameraDistance").value=n.position.distanceTo(s),$.copy(s).project(n),this.screenPosition.set(($.x+1)*.5,($.y+1)*.5)),this.time+=i*this.speed;const u=this.time-l;r.get("radius").value=u,u>=(r.get("maxRadius").value+l)*2&&(this.active=!1,a.value=!1)}}},Gi="uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}",Vi=class extends y{constructor({blendFunction:e,intensity:t=1}={}){super("SepiaEffect",Gi,{blendFunction:e,uniforms:new Map([["weightsR",new o(new D(.393,.769,.189))],["weightsG",new o(new D(.349,.686,.168))],["weightsB",new o(new D(.272,.534,.131))]])})}get intensity(){return this.blendMode.opacity.value}set intensity(e){this.blendMode.opacity.value=e}getIntensity(){return this.intensity}setIntensity(e){this.intensity=e}get weightsR(){return this.uniforms.get("weightsR").value}get weightsG(){return this.uniforms.get("weightsG").value}get weightsB(){return this.uniforms.get("weightsB").value}},Wi=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}`,Ki="uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}",Zi=class extends y{constructor({blendFunction:e,offset:t=0,rotation:i=0,focusArea:s=.4,feather:n=.3,kernelSize:r=W.MEDIUM,resolutionScale:a=.5,resolutionX:l=S.AUTO_SIZE,resolutionY:u=S.AUTO_SIZE}={}){super("TiltShiftEffect",Wi,{vertexShader:Ki,blendFunction:e,uniforms:new Map([["rotation",new o(new T)],["maskParams",new o(new T)],["map",new o(null)]])}),this._offset=t,this._focusArea=s,this._feather=n,this.renderTarget=new C(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="TiltShift.Target",this.uniforms.get("map").value=this.renderTarget.texture,this.blurPass=new zt({kernelSize:r,resolutionScale:a,resolutionX:l,resolutionY:u,offset:t,rotation:i,focusArea:s,feather:n});const c=this.resolution=new S(this,l,u,a);c.addEventListener("change",d=>this.setSize(c.baseWidth,c.baseHeight)),this.rotation=i,this.updateParams()}updateParams(){const e=this.uniforms.get("maskParams").value,t=Math.max(this.focusArea-this.feather,0);e.set(this.offset-t,this.offset+t)}get rotation(){return Math.acos(this.uniforms.get("rotation").value.x)}set rotation(e){this.uniforms.get("rotation").value.set(Math.cos(e),Math.sin(e)),this.blurPass.blurMaterial.rotation=e}get offset(){return this._offset}set offset(e){this._offset=e,this.blurPass.blurMaterial.offset=e,this.updateParams()}get focusArea(){return this._focusArea}set focusArea(e){this._focusArea=e,this.blurPass.blurMaterial.focusArea=e,this.updateParams()}get feather(){return this._feather}set feather(e){this._feather=e,this.blurPass.blurMaterial.feather=e,this.updateParams()}get bias(){return 0}set bias(e){}update(e,t,i){this.blurPass.render(e,t,this.renderTarget)}setSize(e,t){const i=this.resolution;i.setBaseSize(e,t),this.renderTarget.setSize(i.width,i.height),this.blurPass.resolution.copy(i)}initialize(e,t,i){this.blurPass.initialize(e,t,i),i!==void 0&&(this.renderTarget.texture.type=i,e.outputEncoding===x&&(this.renderTarget.texture.encoding=x))}},Xi=`#include <tonemapping_pars_fragment>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
uniform lowp sampler2D luminanceBuffer;uniform float whitePoint;uniform float middleGrey;
#if TONE_MAPPING_MODE != 2
uniform float averageLuminance;
#endif
vec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);
#if TONE_MAPPING_MODE == 2
float lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));
#else
float lumAvg=averageLuminance;
#endif
float lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){
#if TONE_MAPPING_MODE == 1 || TONE_MAPPING_MODE == 2
outputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);
#else
outputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);
#endif
}`,qi=class extends y{constructor({blendFunction:e=h.SRC,adaptive:t=!0,mode:i=t?N.REINHARD2_ADAPTIVE:N.REINHARD2,resolution:s=256,maxLuminance:n=16,whitePoint:r=n,middleGrey:a=.6,minLuminance:l=.01,averageLuminance:u=1,adaptationRate:c=1}={}){super("ToneMappingEffect",Xi,{blendFunction:e,uniforms:new Map([["luminanceBuffer",new o(null)],["maxLuminance",new o(n)],["whitePoint",new o(r)],["middleGrey",new o(a)],["averageLuminance",new o(u)]])}),this.renderTargetLuminance=new C(1,1,{minFilter:Ke,depthBuffer:!1}),this.renderTargetLuminance.texture.generateMipmaps=!0,this.renderTargetLuminance.texture.name="Luminance",this.luminancePass=new Pe({renderTarget:this.renderTargetLuminance}),this.adaptiveLuminancePass=new Bt(this.luminancePass.texture,{minLuminance:l,adaptationRate:c}),this.uniforms.get("luminanceBuffer").value=this.adaptiveLuminancePass.texture,this.resolution=s,this.mode=i}get mode(){return Number(this.defines.get("TONE_MAPPING_MODE"))}set mode(e){if(this.mode!==e){switch(this.defines.clear(),this.defines.set("TONE_MAPPING_MODE",e.toFixed(0)),e){case N.REINHARD:this.defines.set("toneMapping(texel)","ReinhardToneMapping(texel)");break;case N.OPTIMIZED_CINEON:this.defines.set("toneMapping(texel)","OptimizedCineonToneMapping(texel)");break;case N.ACES_FILMIC:this.defines.set("toneMapping(texel)","ACESFilmicToneMapping(texel)");break;default:this.defines.set("toneMapping(texel)","texel");break}this.adaptiveLuminancePass.enabled=e===N.REINHARD2_ADAPTIVE,this.setChanged()}}getMode(){return this.mode}setMode(e){this.mode=e}get whitePoint(){return this.uniforms.get("whitePoint").value}set whitePoint(e){this.uniforms.get("whitePoint").value=e}get middleGrey(){return this.uniforms.get("middleGrey").value}set middleGrey(e){this.uniforms.get("middleGrey").value=e}get averageLuminance(){return this.uniforms.get("averageLuminance").value}set averageLuminance(e){this.uniforms.get("averageLuminance").value=e}get adaptiveLuminanceMaterial(){return this.adaptiveLuminancePass.fullscreenMaterial}getAdaptiveLuminanceMaterial(){return this.adaptiveLuminanceMaterial}get resolution(){return this.luminancePass.resolution.width}set resolution(e){const t=Math.max(0,Math.ceil(Math.log2(e))),i=Math.pow(2,t);this.luminancePass.resolution.setPreferredSize(i,i),this.adaptiveLuminanceMaterial.mipLevel1x1=t}getResolution(){return this.resolution}setResolution(e){this.resolution=e}get adaptive(){return this.mode===N.REINHARD2_ADAPTIVE}set adaptive(e){this.mode=e?N.REINHARD2_ADAPTIVE:N.REINHARD2}get adaptationRate(){return this.adaptiveLuminanceMaterial.adaptationRate}set adaptationRate(e){this.adaptiveLuminanceMaterial.adaptationRate=e}get distinction(){return console.warn(this.name,"distinction was removed."),1}set distinction(e){console.warn(this.name,"distinction was removed.")}update(e,t,i){this.adaptiveLuminancePass.enabled&&(this.luminancePass.render(e,t),this.adaptiveLuminancePass.render(e,null,null,i))}initialize(e,t,i){this.adaptiveLuminancePass.initialize(e,t,i)}},ji=`uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,Yi=class extends y{constructor({blendFunction:e,technique:t=se.DEFAULT,eskil:i=!1,offset:s=.5,darkness:n=.5}={}){super("VignetteEffect",ji,{blendFunction:e,defines:new Map([["VIGNETTE_TECHNIQUE",t.toFixed(0)]]),uniforms:new Map([["offset",new o(s)],["darkness",new o(n)]])})}get technique(){return Number(this.defines.get("VIGNETTE_TECHNIQUE"))}set technique(e){this.technique!==e&&(this.defines.set("VIGNETTE_TECHNIQUE",e.toFixed(0)),this.setChanged())}get eskil(){return this.technique===se.ESKIL}set eskil(e){this.technique=e?se.ESKIL:se.DEFAULT}getTechnique(){return this.technique}setTechnique(e){this.technique=e}get offset(){return this.uniforms.get("offset").value}set offset(e){this.uniforms.get("offset").value=e}getOffset(){return this.offset}setOffset(e){this.offset=e}get darkness(){return this.uniforms.get("darkness").value}set darkness(e){this.uniforms.get("darkness").value=e}getDarkness(){return this.darkness}setDarkness(e){this.darkness=e}};const b=function(e,t){return t===void 0&&(t=h.NORMAL),_.exports.forwardRef(function(s,n){let{blendFunction:r,opacity:a,...l}=s;const u=de(d=>d.invalidate),c=_.exports.useMemo(()=>new e(l),[l]);return _.exports.useLayoutEffect(()=>{c.blendMode.blendFunction=!r&&r!==0?t:r,a!==void 0&&(c.blendMode.opacity.value=a),u()},[r,c.blendMode,a]),re("primitive",{ref:n,object:c,dispose:null})})},$i=b(Ei,h.ADD);b(wi);b(_i);b(Bi);const Ae=_.exports.createContext(null),Ji=Xe.memo(_.exports.forwardRef((e,t)=>{let{children:i,camera:s,scene:n,resolutionScale:r,enabled:a=!0,renderPriority:l=1,autoClear:u=!0,depthBuffer:c,disableNormalPass:d,stencilBuffer:v,multisampling:m=8,frameBufferType:p=je}=e;const{gl:w,scene:L,camera:I,size:K}=de();n=n||L,s=s||I;const[R,z,M]=_.exports.useMemo(()=>{const g=Ye(),E=new Lt(w,{depthBuffer:c,stencilBuffer:v,multisampling:m>0&&g?m:0,frameBufferType:p});E.addPass(new Ue(n,s));let O=null,Y=null;return d||(Y=new It(n,s),Y.enabled=!1,E.addPass(Y),r!==void 0&&g&&(O=new bt({normalBuffer:Y.texture,resolutionScale:r}),O.enabled=!1,E.addPass(O))),[E,Y,O]},[s,w,c,v,m,p,n,d,r]);_.exports.useEffect(()=>R==null?void 0:R.setSize(K.width,K.height),[R,K]),qe((g,E)=>{a&&(w.autoClear=u,R.render(E))},a?l:0);const k=_.exports.useRef(null);_.exports.useLayoutEffect(()=>{let g;return k.current&&k.current.__r3f&&R&&(g=new Ut(s,...k.current.__r3f.objects),g.renderToScreen=!0,R.addPass(g),z&&(z.enabled=!0),M&&(M.enabled=!0)),()=>{g&&(R==null||R.removePass(g)),z&&(z.enabled=!1),M&&(M.enabled=!1)}},[R,i,s,z,M]);const Z=_.exports.useMemo(()=>({composer:R,normalPass:z,downSamplingPass:M,resolutionScale:r,camera:s,scene:n}),[R,z,M,r,s,n]);return _.exports.useImperativeHandle(t,()=>R,[R]),re(Ae.Provider,{value:Z,children:re("group",{ref:k,children:i})})})),es=_.exports.forwardRef(function(t,i){let{target:s,depthTexture:n,...r}=t;const a=de(c=>c.invalidate),{camera:l}=_.exports.useContext(Ae),u=_.exports.useMemo(()=>new bi(l,r),[l,r]);return _.exports.useLayoutEffect(()=>{if(s){const c=s instanceof D?new D().set(s.x,s.y,s.z):new D().set(s[0],s[1],s[2]);u.target=c}n&&u.setDepthTexture(n.texture,n.packing),a()},[s,n,u]),re("primitive",{ref:i,object:u,dispose:null})});b(Ui);b(Ai);const ts=b(zi,h.COLOR_DODGE);b(Fi,h.OVERLAY);b(Vi);b(qi);const is=b(Yi);b(Hi);b(Zi,h.ADD);export{$i as B,es as D,Ji as E,ts as N,is as V};
