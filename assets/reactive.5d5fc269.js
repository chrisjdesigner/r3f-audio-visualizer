var Z=Object.defineProperty;var Y=(e,s,n)=>s in e?Z(e,s,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[s]=n;var y=(e,s,n)=>(Y(e,typeof s!="symbol"?s+"":s,n),n);import{g as q,V as v,T as C,r as c,a as _,B as J,h as D,M as K,Q as X,u as N,C as $,j as ee,b as f,e as b,F as te,E as se,c as ne,f as re}from"./index.c5fa4699.js";const oe=e=>(e%C+C)%C;class L extends q{constructor(n,r,o,a=0){super();y(this,"helixLength");y(this,"helixRadius");y(this,"helixWindingSeparation");y(this,"helixStartingAngleRad");this.helixLength=n,this.helixRadius=r,this.helixWindingSeparation=o,this.helixStartingAngleRad=oe(a)}getPoint(n,r=new v){n-=.5;const a=1/(this.helixLength/this.helixWindingSeparation),t=C*(n%a/a),h=this.helixRadius*Math.cos(t+this.helixStartingAngleRad),u=this.helixRadius*Math.sin(t+this.helixStartingAngleRad),p=this.helixLength*n;return r.set(h,u,p)}}const ae=(e,s)=>Math.hypot(e*Math.sin(s),e*Math.cos(s)-e),U=({coordinateMapper:e,helixLength:s=10,helixWindingSeparation:n=10,helixRadius:r=1,strandRadius:o=.1,baseSpacing:a=.35,strandOffsetRad:t=Math.PI/2,mirrorEffects:h=!0,fixedBaseGap:u=!0,...p})=>{const x=Math.floor(s/a),i=c.exports.useRef(null),A=c.exports.useMemo(()=>new _({color:"#606060"}),[]),j=c.exports.useMemo(()=>{const m=.45*ae(r,t),M=new J(o,o,m,1);for(let d=0;d<M.attributes.position.count;d++)M.attributes.position.setZ(d,M.attributes.position.getZ(d)-m/2);return M.attributes.position.needsUpdate=!0,M},[r,o,t]),F=c.exports.useRef(null),O=c.exports.useRef(null),I=c.exports.useMemo(()=>new _({color:"#d9d9d9"}),[]),[T,Q,V,k]=c.exports.useMemo(()=>{const g=new L(s,r,n,0),m=new L(s,r,n,t);return[g,new D(g,100,o,12,!1),m,new D(m,100,o,12,!1)]},[s,r,n,o,t]),l=c.exports.useMemo(()=>new K,[]),w=c.exports.useMemo(()=>new v,[]),B=c.exports.useMemo(()=>new v,[]),P=c.exports.useMemo(()=>new v,[]),R=c.exports.useMemo(()=>new X,[]),W=c.exports.useMemo(()=>new v(0,0,1),[]);return c.exports.useEffect(()=>{let g=0;for(let m=0;m<x;m++)g=m/Math.max(x-1,1),T.getPoint(g,w),V.getPoint(g,B),l.setPosition(w),l.lookAt(w,B,W),i.current.setMatrixAt(m*2,l),l.setPosition(B),l.lookAt(B,w,W),i.current.setMatrixAt(m*2+1,l);i.current.instanceMatrix.needsUpdate=!0},[T,V,i,x]),N(({clock:g})=>{const m=g.getElapsedTime();let M=0,d=0,H=0,z=0;const E=.25,G=1;for(let S=0;S<x;S++)M=S/Math.max(x-1,1),d=e.map($.CARTESIAN_1D,h?2*Math.abs(M-.5):M,0,0,m)/e.amplitude,d=(1+d)/2,H=E+(u?2*d:d)*(G-E),z=u?E+2*(1-d)*(G-E):H,i.current.getMatrixAt(S*2,l),l.decompose(w,R,P),P.z=H,l.compose(w,R,P),i.current.setMatrixAt(S*2,l),i.current.getMatrixAt(S*2+1,l),l.decompose(B,R,P),P.z=z,l.compose(B,R,P),i.current.setMatrixAt(S*2+1,l);i.current.instanceMatrix.needsUpdate=!0}),ee("group",{...p,children:[f("mesh",{ref:F,geometry:Q,material:I,castShadow:!0,receiveShadow:!0}),f("mesh",{ref:O,geometry:k,material:I,castShadow:!0,receiveShadow:!0}),f("instancedMesh",{ref:i,args:[j,A,2*x],castShadow:!0,receiveShadow:!0})]})},ie=({...e})=>{const r=Array.from({length:12}).map(a=>c.exports.useRef(null)),o=Array.from({length:12}).map((a,t)=>new v().fromArray(Array.from({length:3}).map((h,u)=>2*b.seededRandom(t+u)-1)).normalize().multiplyScalar(15));return N(({clock:a})=>{const t=a.getElapsedTime(),h=5e-4,u=.05;let p,x=0;r.forEach((i,A)=>{!i.current||(p=o[A],x=Math.sin(u*(.5+.5*b.seededRandom(A))*t+b.seededRandom(A)/u),i.current.position.set(p.x*x,p.y*x,p.z*x),i.current.rotation.z+=h*Math.cos((.5+.5*b.seededRandom(A))*t),i.current.rotation.y+=h*Math.cos((.5+.5*b.seededRandom(A))*t))})}),f(te,{children:r.map((a,t)=>f("group",{ref:a,position:o[t],rotation:new se(...Array.from({length:3}).map((h,u)=>Math.PI*(2*b.seededRandom(t+u)-1))),children:f(U,{...e})},t))})},le=({coordinateMapper:e})=>{const{multi:s,helixLength:n,helixRadius:r,helixWindingSeparation:o,strandRadius:a,baseSpacing:t,strandOffsetRad:h,mirrorEffects:u,fixedBaseGap:p}=ne({"Visual - DNA":re({multi:!0,helixLength:{value:15,min:5,max:100,step:5},helixRadius:{value:1,min:1,max:5,step:1},helixWindingSeparation:{value:10,min:5,max:50,step:1},strandRadius:{value:.1,min:.1,max:.3,step:.1},baseSpacing:{value:.35,min:.1,max:2,step:.05},strandOffsetRad:{value:Math.PI/2,min:Math.PI/4,max:Math.PI,step:Math.PI/8},mirrorEffects:!0,fixedBaseGap:!1},{collapsed:!0})});return s?f(ie,{coordinateMapper:e,helixLength:n,helixRadius:r,helixWindingSeparation:o,strandRadius:a,baseSpacing:t,strandOffsetRad:h,mirrorEffects:u,fixedBaseGap:p}):f(U,{coordinateMapper:e,helixLength:n,helixRadius:r,helixWindingSeparation:o,strandRadius:a,baseSpacing:t,strandOffsetRad:h,mirrorEffects:u,fixedBaseGap:p})};export{le as default};
