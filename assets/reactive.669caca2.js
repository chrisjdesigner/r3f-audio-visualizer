import{r as m,a as x,b as f,j as i,_ as h,d as R,f as b,u as c,E as C,F as S,V as T}from"./index.e77f1834.js";import{G as v}from"./ground.4a3bf608.js";const g=()=>{let a=0,s=0;for(;a===0;)a=Math.random();for(;s===0;)s=Math.random();let e=Math.sqrt(-2*Math.log(a))*Math.cos(h*s);return e=e/10+.5,e>1||e<0?g():e},w=({coordinateMapper:a,radius:s=2,pointSize:e=.2,nPoints:r=1e3})=>{const n=[...Array(r)].map(g),t=m.exports.useRef(null);return x(({clock:M})=>{const y=M.getElapsedTime();let u,p,d;const l=t.current.geometry.attributes.position;for(let o=0;o<r;o++)p=o/(r-1),d=p*h,u=s*(1+n[o]*a.map(p,0,0,y)),l.setXYZ(o,u*Math.cos(d),u*Math.sin(d),0);l.needsUpdate=!0}),f("points",{ref:t,children:[i("bufferGeometry",{children:i("bufferAttribute",{attach:"attributes-position",array:new Float32Array(r*3),count:r,itemSize:3})}),i("pointsMaterial",{attach:"material",size:e})]})},E=({})=>{const{radius:a,pointSize:s}=R({Ring:b({radius:{value:2,min:.25,max:3,step:.25},pointSize:{value:.2,min:.01,max:2,step:.01}},{collapsed:!0})}),e=c(t=>t.amplitude),r=c(t=>t.coordinateMapper),n=c(t=>t.updateCoordinateType);return m.exports.useEffect(()=>{n(C.Cartesian_1D)},[]),f(S,{children:[i(w,{coordinateMapper:r,radius:a,pointSize:s}),i(v,{position:new T(0,0,-1.5*e)})]})};export{E as default};
